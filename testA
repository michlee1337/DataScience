{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Assignment 1\n",
    "CS154 Fall 2019\n",
    "\n",
    "Michelle S Lee"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q1: Dimensional Analysis and Linear Algebra"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Appropriate Combinations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Systems of Linear Equations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_______\n",
    "**Finding $[M]$**\n",
    "\n",
    "We know that $[M]$ must be some combination of $$(x1)^\\alpha(x2)^\\beta(x3)^\\gamma$$\n",
    "\n",
    "We can sub in the dimensions for each physical variable and rewrite the left of the equation to contain the same values as the right.\n",
    "\n",
    "$$[M]^1[L]^0[T]^0 = ([M]^{a_1}[L]^{b_1}[T]^{c_1})^\\alpha([M]^{a_2}[L]^{b_2}[T]^{c_2})^\\beta([M]^{a_3}[L]^{b_3}[T]^{c_3})^\\gamma$$\n",
    "\n",
    "This results in the following system of linear equations\n",
    "\n",
    "$$1 = a_1\\alpha+a_2\\beta+a_3\\gamma$$\n",
    "$$0 = b_1\\alpha+b_2\\beta+b_3\\gamma$$\n",
    "$$0 = c_1\\alpha+c_2\\beta+c_3\\gamma$$\n",
    "\n",
    "Rewritten in matrix form, this looks like\n",
    "$$\\left(\\begin{array}{cc} \n",
    "a_1 & a_2 & a_3\\\\\n",
    "b_1 & b_2 & b_3\\\\\n",
    "c_1 & c_2 & c_3\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "1\\\\\n",
    "0\\\\\n",
    "0\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "_______\n",
    "\n",
    "The same proccess can be replicated to find $[L]$ and $[T]$, with the only difference being the resulting combination of fundamental variables that we're looking for.\n",
    "_______\n",
    "**Finding $[L]$**\n",
    "\n",
    "$$[M]^0[L]^1[T]^0 = ([M]^{a_1}[L]^{b_1}[T]^{c_1})^\\alpha([M]^{a_2}[L]^{b_2}[T]^{c_2})^\\beta([M]^{a_3}[L]^{b_3}[T]^{c_3})^\\gamma$$\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "a_1 & a_2 & a_3\\\\\n",
    "b_1 & b_2 & b_3\\\\\n",
    "c_1 & c_2 & c_3\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "1\\\\\n",
    "0\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "_______\n",
    "**Finding $[T]$**\n",
    "\n",
    "$$[M]^0[L]^0[T]^1 = ([M]^{a_1}[L]^{b_1}[T]^{c_1})^\\alpha([M]^{a_2}[L]^{b_2}[T]^{c_2})^\\beta([M]^{a_3}[L]^{b_3}[T]^{c_3})^\\gamma$$\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "a_1 & a_2 & a_3\\\\\n",
    "b_1 & b_2 & b_3\\\\\n",
    "c_1 & c_2 & c_3\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "0\\\\\n",
    "1\n",
    "\\end{array}\\right)$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We could solve all three of these systems of linear equations by multiplying both sides of the equations by the inverse of the coefficient matrix*. \n",
    "\n",
    "The only risk to this approach would be if the coefficient matrix was singular (not invertible). However, a coefficient matrix is only singular if it contains either a row or column of zeroes. \n",
    "\n",
    "If the coefficient matrix contains a row of zeros, then the physical variable that the row corresponds to is already dimensionless**. Thus, that variable should not be considered when trying to derive the fundamental variables. \n",
    "\n",
    "If a column contains a row of zeros, then none of the physical variables contains that fundamental unit*** and thus we do not need to derive that fundamental variable as it is not relevant to our variables.\n",
    "\n",
    "Another risk would be if the matrix was not square. However, if the coefficient matrix was not square that would mean that we are either considering more fundamental variables than physical variables, or more physical variables than fundamental variables. If we have more fundamental variables than physical variables to consider, then non-dimensionalisation is not possible. If we have more physical variables than fundamental variables, then we have some redundant physical variables (can be expressed as a linear combindation of the others) that can be left out from the equation.\n",
    "______\n",
    "\\* The coefficient matrix is $$\\left(\\begin{array}{cc} \n",
    "a_1 & a_2 & a_3\\\\\n",
    "b_1 & b_2 & b_3\\\\\n",
    "c_1 & c_2 & c_3\n",
    "\\end{array}\\right)$$\n",
    "______\n",
    "\\** For example, if the first row was all zeroes, that would mean\n",
    "$$ x_1 = [M]^{0}[L]^{0}[T]^{0}$$\n",
    "Which would mean that $x_1$ is dimensionless. This can be generalized to any of the physical variables.\n",
    "______\n",
    "\\*** For example, if the first column was all zeroes, that would mean\n",
    "$$ x_1 = [M]^{0}[L]^{b_1}[T]^{c_1}$$\n",
    "$$ x_2 = [M]^{0}[L]^{b_2}[T]^{c_2}$$\n",
    "$$ x_3 = [M]^{0}[L]^{b_3}[T]^{c_3}$$\n",
    "Which would mean that\n",
    "$$ x_1 = [L]^{b_1}[T]^{c_1}$$\n",
    "$$ x_2 = [L]^{b_2}[T]^{c_2}$$\n",
    "$$ x_3 = [L]^{b_3}[T]^{c_3}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Comparing the Systems"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The coefficient matrices are exactly the same. \n",
    "\n",
    "The rows represent the powers of each of the fundamental variables in a physical variable. \n",
    "\n",
    "The columns represent the powers of a fundamental variable involved in each of the physical variables.\n",
    "\n",
    "The set of the right hand side vectors of all the systems form a basis of dimension $R^n$ where $n$ is the number of fundamental variables we are trying to derive. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using the Framework"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Writing the physical quantities in terms of fundamental variables      \n",
    "$$w = M^1L^1T^{-2}$$     \n",
    "$$h = M^0L^1T^0$$     \n",
    "$$q = M^0L^3T^{-1}$$    \n",
    "\n",
    "_______\n",
    "Finding $M$\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 1 & -2\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 3 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "1\\\\\n",
    "0\\\\\n",
    "0\n",
    "\\end{array}\\right)$$\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "solution:  [ 1.  5. -2.]\n"
     ]
    }
   ],
   "source": [
    "A = np.array([[1,0,0],[1,1,3],[-2,0,-1]])\n",
    "bM = np.array([1,0,0])\n",
    "xM = np.linalg.solve(A,bM)\n",
    "\n",
    "if (A@xM == bM).all:\n",
    "    print(\"solution: \", xM)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 1 & -2\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 3 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "1\\\\\n",
    "5\\\\\n",
    "-2\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "1\\\\\n",
    "0\\\\\n",
    "0\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "$$M = wh^5q^{-2}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_______\n",
    "Finding $L$\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 1 & -2\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 3 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "1\\\\\n",
    "0\n",
    "\\end{array}\\right)$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "solution:  [-0.  1. -0.]\n"
     ]
    }
   ],
   "source": [
    "bL = np.array([0,1,0])\n",
    "xL = np.linalg.solve(A,bL)\n",
    "\n",
    "if (A@xL == bL).all:\n",
    "    print(\"solution: \", xL)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 1 & -2\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 3 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "1\\\\\n",
    "0\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "1\\\\\n",
    "0\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "$$L = h$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_______\n",
    "Finding $T$\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 1 & -2\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 3 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "0\\\\\n",
    "1\n",
    "\\end{array}\\right)$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "solution:  [-0.  3. -1.]\n"
     ]
    }
   ],
   "source": [
    "bT = np.array([0,0,1])\n",
    "xT = np.linalg.solve(A,bT)\n",
    "\n",
    "if (A@xT == bT).all:\n",
    "    print(\"solution: \", xT)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 1 & -2\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 3 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "3\\\\\n",
    "-1\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "0\\\\\n",
    "1\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "$$T = h^3q^{-1}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Combination with Units"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Using Linear Equations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We have already found the vectors that allowed us to express the fundamental units in terms of the physical quantities. Putting these vectors together allows us to create a change of basis matrix from the fundamental units to the physical quanties.\n",
    "\n",
    "Algebraicly, all we are doing is replacing the fundamental units with their equivalents expressed in physical quantities which we found in the last question\n",
    "\n",
    "Finding $x_4 = M^{a_4}L^{b_4}T^{c_4}$\n",
    "\n",
    "$$M^{a_4}L^{b_4}T^{c_4}= (wh^5q^{-2})^{a_4}(h)^{b_4}(h^3q^{-1})^{c_4}$$\n",
    "\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "5 & 1 & 3\\\\\n",
    "-2 & 0 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "a_4\\\\\n",
    "b_4\\\\\n",
    "c_4\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "\n",
    "Using this change of basis matrix, we can change the way we express the variable $x_4$ from fundamental units to physical quantities by solving this equation. To solve this equation, we just left multiply the vector of fundamental units (coordinates in the old basis) by the change of basis matrix.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Explaining with Basis and Linear Combinations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Essentially through this process, we are just changing the basis. In section (a), we were finding the change of basis matrix from the physical variables to the fundamental units. In section (c), we use that change of basis matrix to change the way we express a variable from physical variables to fundamental units. The reason we can do part(a) is that all fundamental units can be expressed as a linear combination of the physical variables (assuming enough non-conflicting independent linear equations). We can do part(c) because vice versa is also True by linearity.\n",
    "\n",
    "As discused in part a)i), this method would fail if the coefficient matrix was not invertible. In that section, I also discussed how that would only be possible if we were trying to undimensionalise non-dimensional variables, if we were trying to express a fundamental unit that was not used in any of our physical variables, if we were using redundant physical units that were unecessary, or if we simply have insuffient information/ equations/ variables to fully non-dimensionalize."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Expressing Power"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$P = ML^2T^{-3}$$\n",
    "$$P= (wh^5q^{-2})^1(h)^2(h^3q^{-1})^{-3}$$\n",
    "\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "5 & 1 & 3\\\\\n",
    "-2 & 0 & -1\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "1\\\\\n",
    "2\\\\\n",
    "-3\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "\n",
    "Using this change of basis matrix, we can change the way we express the variable $x_4$ from fundamental units to physical quantities by solving this equation. To solve this equation, we simply complete the left multiplication by the change of basis matrix.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 1.]\n",
      " [-2.]\n",
      " [ 1.]]\n"
     ]
    }
   ],
   "source": [
    "AN = np.linalg.solve(A,np.array([[1,0,0],[0,1,0],[0,0,1]]))\n",
    "xN = np.array([[1],[2],[-3]])\n",
    "bN = AN.dot(xN)\n",
    "if (AN@xN == bN).all():\n",
    "    print(bN)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$P =  wh^{-2}q$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Optional: Automate"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Q2: Data Interpolation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Lagrange Cubic Spline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We know that:\n",
    "\n",
    "$$f_i''(x_i)=k_i$$\n",
    "$$f_i''(x_{i+1})=k_{i+1}$$\n",
    "$$x_{i+1}=x_i+h$$\n",
    "\n",
    "And that the second derivative of the global polynomial is linear and can be written as: \n",
    "$$f_i''(x)=\\frac{x_{i+1}-x}{h}k_{i} + \\frac{x-x_{i}}{h}k_{i+1}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Integrate"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can integrate this twice to get the cubic function\n",
    "\n",
    "$$f_i(x)=\\int \\Bigg( \\int \\Bigg(\\frac{x_{i+1}-x_i}{h}k_{i+1} + \\frac{x_i-x_{i+1}}{h}k_i \\Bigg) dx \\Bigg) dx$$\n",
    "\n",
    "$$f_i(x)=\\frac{(x_{i+1}-x)^3}{6h}k_i+\\frac{(x-x_i)^3}{6h}k_{i+1} + A_ix + B_i$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Expressing the Constants"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Subbing in $f_i(x_i) = y_i$\n",
    "\n",
    "$$y_i=\\frac{(x_{i+1}-x_i)^3}{6h}k_i+\\frac{(x_i-x_i)^3}{6h}k_{i+1} + A_i(x_i) + B_i$$\n",
    "$$y_i=\\frac{(x_{i+1}-x_i)^3}{6h}k_i+ A_i(x_i) + B_i$$\n",
    "\n",
    "\n",
    "Subbing in $x_{i+1} = x_i+h$\n",
    "\n",
    "$$y_i=\\frac{h^2}{6}k_i + A_i(x_i) + B_i$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Subbing in $f_i(x_{i+1}) = y_{i+1}$\n",
    "\n",
    "$$y_{i+1}=\\frac{(x_{i+1}-x_{i+1})^3}{6h}k_i+\\frac{(x_i-x_{i+1})^3}{6h}k_{i+1} + A_i(x_{i+1}) + B_i$$\n",
    "$$y_{i+1}=\\frac{(x_i-x_{i+1})^3}{6h}k_{i+1}+ A_i(x_{i+1}) + B_i$$\n",
    "\n",
    "\n",
    "Subbing in $x_{i+1} = x_i+h$\n",
    "\n",
    "$$y_{i+1}=\\frac{h^2}{6}k_{i+1} + A_i(x_{i+1}) + B_i$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Expressing $A_i$ by subtracting $y_{i+1}$ from $y_i$\n",
    "\n",
    "$$y_{i+1}-y_i = \\frac{h^2}{6}(k_{i+1}-k_i) + A_i(x_{i+1}-x_i)$$\n",
    "$$A_i(x_{i+1}-x_i) = y_{i+1}-y_i - \\frac{h^2}{6}(k_{i+1}-k_i)$$\n",
    "\n",
    "Subbing in $x_{i+1} = x_i+h$\n",
    "$$A_i = \\frac{y_{i+1}-y_i - \\frac{h^2}{6}(k_{i+1}-k_i)}{h}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Similarly with $B_i$\n",
    "\n",
    "$$B_i = \\frac{x_{i+1}y_i - x_iy_{i+1}-\\frac{h^2}{6}(x_{i+1}k_i - x_{i}k_{i+1})}{h} $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Shifting Indices"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The entire process is exactly the same except that we are replacing $x_i$ with $x_{i+1}$, $x_{i+1}$ with $x_{i+2}$, $k_i$ with $k_{i+1}$, $k_{i+1}$ with $k_{i+2}$, $A_{i}$ with $A_{i+1}$, and $B_{i}$ with $B_{i+1}$. Because they are all unique variables, the algebraic manipulation will be the same.\n",
    "\n",
    "Thus,\n",
    "$$f_{i+1}(x)=\\frac{(x_{i+2}-x)^3}{6h}k_{i+1}+\\frac{(x-x_{i+1})^3}{6h}k_{i+2} + A_{i+1}x + B_{i+1}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## $k'$ in terms of $y'$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$f_i(x)=\\frac{(x_{i+1}-x)^3}{6h}k_i+\\frac{(x-x_i)^3}{6h}k_{i+1} + A_ix + B_i$$\n",
    "\n",
    "Subbing in the derived $A_i$ and $B_i$\n",
    "\n",
    "$$f_i(x)=\\frac{(x_{i+1}-x)^3}{6h}k_i+\\frac{(x-x_i)^3}{6h}k_{i+1} + \\frac{y_{i+1}-y_i - \\frac{h^2}{6}(k_{i+1}-k_i)}{h}\n",
    "x + \\frac{x_{i+1}y_i - x_iy_{i+1}-\\frac{h^2}{6}(x_{i+1}k_i - x_{i}k_{i+1})}{h}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Deriving to find $f_i'(x)$\n",
    "\n",
    "$$f_i'(x)=-\\frac{(x_{i+1}-x)^2}{2h}k_i+\\frac{(x-x_i)^2}{2h}k_{i+1} + \\frac{y_{i+1}-y_i - \\frac{h^2}{6}(k_{i+1}-k_i)}{h}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finding $f'_i(x_{i+1})$\n",
    "\n",
    "$$f_i'(x_{i+1})=-\\frac{(x_{i+1}-x_{i+1})^2}{2h}k_i+\\frac{(x_{i+1}-x_i)^2}{2h}k_{i+1} + \\frac{y_{i+1}-y_i - \\frac{h^2}{6}(k_{i+1}-k_i)}{h}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$f_i'(x_{i+1})=\\frac{h}{2}k_{i+1} + \\frac{y_{i+1}-y_i - \\frac{h^2}{6}(k_{i+1}-k_i)}{h}$$\n",
    "\n",
    "$$f_i'(x_{i+1})=\\frac{h}{2}k_{i+1} + \\frac{y_{i+1}-y_i}{h} - \\frac{h}{6}k_{i+1} + \\frac{h}{6}k_i$$\n",
    "\n",
    "$$f_i'(x_{i+1})= -\\frac{h}{3}k_{i+1} + \\frac{y_{i+1}-y_i}{h} +\\frac{h}{6}k_{i}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finding $f'_{i+1}(x)$\n",
    "\n",
    "$$f_{i+1}(x) = \\frac{(x_{i+2}-x)^3}{6h}k_{i+1}+\\frac{(x-x_{i+1})^3}{6h}k_{i+2} + A_{i+1}x + B_{i+1}$$\n",
    "\n",
    "\n",
    "$$f'_{i+1}(x) = -\\frac{(x_{i+2}-x)^2}{2h}k_{i+1}+\\frac{(x-x_{i+1})^2}{2h}k_{i+2} + A_{i+1}$$\n",
    "\n",
    "$$f'_{i+1}(x_{i+1}) = -\\frac{(x_{i+2}-x_{i+1})^2}{2h}k_{i+1}+\\frac{(x_{i+1}-x_{i+1})^2}{2h}k_{i+2} + A_{i+1}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$f'_{i+1}(x_{i+1}) = -\\frac{h}{2}k_{i+1} + A_{i+1}$$\n",
    "\n",
    "Subbing in $A_{i+1}$\n",
    "\n",
    "$$f'_{i+1}(x_{i+1}) = -\\frac{h}{2}k_{i+1} + \\frac{y_{i+2}-y_{i+1} - \\frac{h^2}{6}(k_{i+2}-k_{i+1})}{h}$$\n",
    "\n",
    "\n",
    "$$f'_{i+1}(x_{i+1}) = -\\frac{h}{2}k_{i+1} + \\frac{y_{i+2}-y_{i+1}}{h} - \\frac{h}{6}(k_{i+2}-k_{i+1})$$\n",
    "\n",
    "$$f'_{i+1}(x_{i+1}) = -\\frac{h}{3}k_{i+1} + \\frac{y_{i+2}-y_{i+1}}{h} - \\frac{h}{6}k_{i+2}$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since $f_i'(x_{i+1}) = f'_{i+1}(x_{i+1})$\n",
    "\n",
    "$$\\frac{h}{3}k_{i+1} + \\frac{y_{i+1}-y_i}{h} + \\frac{h}{6}k_{i} = -\\frac{h}{3}k_{i+1} + \\frac{y_{i+2}-y_{i+1}}{h} - \\frac{h}{6}k_{i+2}$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$2hk_{i+1} + \\frac{6(y_{i+1}-y_i)}{h} + hk_{i} = -2hk_{i+1} + \\frac{6(y_{i+2}-y_{i+1})}{h} - hk_{i+2}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$2hk_{i+1} + \\frac{6(y_{i+1}-y_i)}{h} + hk_{i} = -2hk_{i+1} + \\frac{6(y_{i+2}-y_{i+1})}{h} - hk_{i+2}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$hk_{i} + 4hk_{i+1} +  hk_{i+2} = \\frac{6(y_{i+2}-y_{i+1})}{h} - \\frac{6(y_{i+1}-y_i)}{h}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$hk_{i} + 4hk_{i+1} +  hk_{i+2} = 6 \\Bigg( \\frac{y_{i+2}-y_{i+1}}{h} - \\frac{y_{i+1}-y_i}{h} \\Bigg)$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Full system of Equations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since we can assume a natural spline\n",
    "$$f_i''(x)=\\frac{x_{i+1}-x}{h}k_{i} + \\frac{x-x_{i}}{h}k_{i+1}$$\n",
    "\n",
    "$$f_1''(x_1) == 0$$\n",
    "\n",
    "$$f_1''(x_1)=\\frac{x_2-x_1}{h}k_{1} + \\frac{x_1-x_{1}}{h}k_{2}$$\n",
    "\n",
    "$$\\frac{x_2-x_1}{h}k_{1} = 0$$\n",
    "\n",
    "$$f_n'(x_{n+1}) == 0$$\n",
    "$$f_n''(x_n+1)=\\frac{x_{n+1}-x_{n+1}}{h}k_{n} + \\frac{x_{n+1}-x_{n}}{h}k_{n+1}$$\n",
    "\n",
    "$$\\frac{x_{n+1}-x_{n}}{h}k_{n+1}=0$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using the two equations we derived for the natural spline above combined with the equation we derived in (e), we can define a set of matrices by which we can solve for the unknown $k$s\n",
    "\n",
    "$$\\frac{x_2-x_1}{h}k_{1} = 0$$\n",
    "$$\\frac{x_{n+1}-x_{n}}{h}k_{n+1}=0$$\n",
    "for each datapoint $i$,\n",
    "$$\\frac{h^2}{6}k_{i} + \\frac{4h^2}{6}k_{i+1} +  \\frac{h^2}{6}k_{i+2} = y_i-2y_{i+1}+y_{i+2}$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We would want to solve for the matrix of $k$s in the following equation:\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "\\frac{x_2-x_1}{h} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & ...\\\\\n",
    "\\frac{h^2}{6} & \\frac{4h^2}{6} & \\frac{h^2}{6} & 0 & 0 & 0 & 0 & 0 & ...\\\\\n",
    "0 & \\frac{h^2}{6} & \\frac{4h^2}{6} & \\frac{h^2}{6} & 0 & 0 & 0 & 0 & ...\\\\\n",
    "&&&&...\\\\\n",
    "&&&&&&... && \\frac{x_{n+1}-x_n}{h}\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "k_1\\\\\n",
    "k_2\\\\\n",
    "k_3\\\\\n",
    "...\\\\\n",
    "\\\\\n",
    "k_{n+1}\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "0\\\\\n",
    "y_1-2y_2+y_3\\\\\n",
    "y_2-2y_3+y_4\\\\\n",
    "...\\\\\n",
    "\\\\\n",
    "0\n",
    "\\end{array}\\right)$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Implementation and Comparison"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Cubic Spline without Lagrange**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cubicSpline(x1,x2,x3,y1,y2,y3):\n",
    "    A = np.array([[x1**3,x1**2,x1,1,0,0,0,0],[x2**3,x2**2,x2,1,0,0,0,0],[0,0,0,0,x2**3,x2**2,x2,1],[0,0,0,0,x3**3,x3**2,x3,1],[3*x2**2,2*x2,0,0,-3*x2**2,-2*x2,0,0],[6*x2,2,0,0,-6*x2,-2,0,0],[6*x1,2,0,0,0,0,0,0],[0,0,0,0,6*x3,2,0,0]])\n",
    "    return(A@np.array([y1,y2,y2,y3,0,0,0,0]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Cubic Spline with Lagrange**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cubicSplineLagrange(points):\n",
    "    #___INITIATE__\n",
    "    n = len(points)\n",
    "    h = points[1] - points[0]\n",
    "    \n",
    "    #___CREATE COEF MATRIX (A)__\n",
    "    # initiate first row of matrix with the starting natural spline condition\n",
    "    A = [[(points[1]-points[0])/h] + [0 for _ in range(n-1)]]\n",
    "    # add a row of equations for each datapoint\n",
    "    for row in range(1,n):\n",
    "        A.append([0 for _ in range(row-1)] + [h**2/6, 4*h**2/6,h**2/6] + [0 for _ in range(n-row-2)])\n",
    "    # add the final natural spline condition\n",
    "    A.append([0 for _ in range(n-1)] + [(x[-1]-x[-2])/h])\n",
    "    A = np.array(A)\n",
    "\n",
    "    #___CREATE RESULT VECTOR (b)__\n",
    "    b = np.array([0] + [y[i]-2*y[i+1]+y[i+2] for i in range(n)] + [0])\n",
    "    \n",
    "    #___SOLVE FOR VECTOR OF UNKNOWNS (x/k)__\n",
    "    return(A@b)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Making use of the Lagrange method makes it much easier to compute cubic splines for a large number of datapoints. \n",
    "\n",
    "While it is definitely possible to generalize the cubic spline method without Lagrange to handle mutiple datapoints, it would involve a lot of algebraic manipulation as we will have to derive and solve for many unique equations. \n",
    "\n",
    "In contrast, making use of the symmetry in the equations using Lagrange allows us to easily solve for a theoretically unlimited number of datapoints without doing any additional algebra.\n",
    "\n",
    "In theory, both of these algorithms should take O(n) time, where n is the number of datapoints involved. This is because we do a \"fixed\" number of steps for each datapoint we are considering. That said even though both the equations take the same order of magnitude of time, the reduction of the coefficient on that time complexity is still notable.\n",
    "\n",
    "Additionally, the Lagrange algotihm will be undoubtably more elegant and readable.\n",
    "\n",
    "A similar argument can be made for space complexity"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "# Q3: Non-linear systems"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Dimensions of Lift and Drag"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$mgsin(\\theta)+\\frac{1}{2}\\rho v^2C_DA=0$$\n",
    "$$\\frac{1}{2}\\rho v^2C_DA=-mgsin(\\theta)$$\n",
    "\n",
    "$$\\frac{M}{L^3} (\\frac{L}{T})^2C_DL^2=-M*\\frac{L}{T^2}$$\n",
    "$$\\frac{ML}{T^2}C_D=-\\frac{ML}{T^2}$$\n",
    "\n",
    "Thus, $C_D$ must be dimensionless to make the dimesnions on both sides of the equation equal.\n",
    "\n",
    "The same process can be repeated to find $C_L$:\n",
    "$$mgcos(\\theta)-\\frac{1}{2}\\rho v^2C_LA=0$$\n",
    "$$\\frac{1}{2}\\rho v^2C_LA=mgcos(\\theta)$$\n",
    "\n",
    "$$\\frac{M}{L^3} (\\frac{L}{T})^2C_LL^2=M*\\frac{L}{T^2}$$\n",
    "$$\\frac{ML}{T^2}C_L=\\frac{ML}{T^2}$$\n",
    "\n",
    "Thus, $C_L$ must be dimensionless to make the dimesnions on both sides of the equation equal.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Expressions of Fundamental Units"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$m = M$$\n",
    "$$g = LT^{-2}$$\n",
    "$$A = L^2$$\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "0 & 1 & -2\\\\\n",
    "0 & 2 & 0\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "M\\\\\n",
    "L\\\\\n",
    "T\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "0 & 1 & -2\\\\\n",
    "0 & 2 & 0\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "\\alpha\\\\\n",
    "\\beta\\\\\n",
    "\\gamma\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 0 & 1\n",
    "\\end{array}\\right)$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 1.  ,  0.  ,  0.  ],\n",
       "       [-0.  , -0.  , -0.5 ],\n",
       "       [ 0.  ,  0.5 ,  0.25]])"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.solve(np.array([[1,0,0],[0,1,2],[0,-2,0]]),np.array([[1,0,0],[0,1,0],[0,0,1]]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "0 & 1 & -2\\\\\n",
    "0 & 2 & 0\n",
    "\\end{array}\\right)\n",
    "\\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "0 & 0 & 0.5\\\\\n",
    "0 & -0.5 & 0.25\n",
    "\\end{array}\\right) = \\left(\\begin{array}{cc} \n",
    "1 & 0 & 0\\\\\n",
    "0 & 1 & 0\\\\\n",
    "0 & 0 & 1\n",
    "\\end{array}\\right)$$\n",
    "\n",
    "\n",
    "$$M = m$$\n",
    "$$L = A^{0.5}$$\n",
    "$$T = g^{-0.5}A^{0.25}$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##  Non-dimensionalize the System"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$v = LT^{-1}$$\n",
    "$$v = A^{0.5}(g^{-0.5}A^{0.25})^{-1}$$\n",
    "$$v = g^{0.5}A^{0.25}$$\n",
    "$$\\bar v = v/v$$\n",
    "$$\\bar v = v/(g^{0.5}A^{0.25})$$\n",
    "$$v = \\bar v(g^{0.5}A^{0.25})$$\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "$$\\rho = ML^{-3}$$\n",
    "$$\\rho = m(A^{0.5})^{-3}$$\n",
    "$$\\rho = mA^{-1.5}$$\n",
    "$$\\bar \\rho = \\rho / \\rho$$\n",
    "$$\\bar \\rho = \\rho /(mA^{-1.5})$$\n",
    "$$\\rho = \\bar \\rho (mA^{-1.5})$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.  , 0.5 , 0.25])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.solve(np.array([[1,0,0],[0,1,2],[0,-2,0]]),np.array([[1,0,0],[0,1,0],[0,0,1]])).dot(np.array([0,1,-1]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 1. ,  0. , -1.5])"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.linalg.solve(np.array([[1,0,0],[0,1,2],[0,-2,0]]),np.array([[1,0,0],[0,1,0],[0,0,1]])).dot(np.array([1,-3,0]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$mgsin(\\theta)+\\frac{1}{2}\\rho v^2C_DA=0$$\n",
    "$$mgsin(\\theta)=-\\frac{1}{2}\\rho v^2C_DA$$\n",
    "$$\\frac{-2mgsin(\\theta)}{C_DA}=\\rho v^2$$\n",
    "$$\\frac{-2mgsin(\\theta)}{C_DA}=\\bar \\rho (mA^{-1.5}) (\\bar v(g^{0.5}A^{0.25}))^2$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\\frac{-2mgsin(\\theta)}{C_DA}=\\bar \\rho mA^{-1} \\bar v^2g$$\n",
    "\n",
    "$$C_D = \\frac{-2mgsin(\\theta)}{\\bar \\rho m\\bar v^2g}$$\n",
    "\n",
    "$$C_D = \\frac{-2sin(\\theta)}{\\bar \\rho \\bar v^2}$$\n",
    "\n",
    "The same process can be done to find $C_L$\n",
    "$$C_L = \\frac{2cos(\\theta)}{\\bar \\rho \\bar v^2}$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Newton's Method"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$1 = \\frac{2cos(\\theta)}{\\bar \\rho \\bar v^2}$$\n",
    "\n",
    "$$\\bar v^2 = 2cos(\\theta)$$\n",
    "$$\\theta = cos^{-1}(\\frac{\\bar v^2}{2})$$\n",
    "$$\\frac{\\delta}{\\delta \\theta} =-\\frac{x}{\\sqrt{1-\\frac{x^4}{4}}}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Root is at:  1.4\n",
      "f(x) at root is:  0.20033484232312024\n"
     ]
    }
   ],
   "source": [
    "import math\n",
    "def dx(f, x):\n",
    "    return abs(0-f(x))\n",
    "\n",
    "def newtons_method(f, df, x0, e):\n",
    "    delta = dx(f, x0)\n",
    "    while delta > e:\n",
    "        x0 = x0 - f(x0)/df(x0)\n",
    "        delta = dx(f, x0)\n",
    "    print('Root is at: ', x0)\n",
    "    print('f(x) at root is: ', f(x0))\n",
    "\n",
    "def f(x):\n",
    "    return(math.acos(x**2/2))\n",
    "\n",
    "def df(x):\n",
    "    return(-x/(math.sqrt(1-x**4/4)))\n",
    "\n",
    "if __name__==\"__main__\":\n",
    "    newtons_method(f, df, 1.4, 0.3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "math domain error",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-19-c66369cbf351>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     18\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     19\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0m__name__\u001b[0m\u001b[0;34m==\u001b[0m\u001b[0;34m\"__main__\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 20\u001b[0;31m     \u001b[0mnewtons_method\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1.3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.3\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m<ipython-input-19-c66369cbf351>\u001b[0m in \u001b[0;36mnewtons_method\u001b[0;34m(f, df, x0, e)\u001b[0m\n\u001b[1;32m      7\u001b[0m     \u001b[0;32mwhile\u001b[0m \u001b[0mdelta\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m         \u001b[0mx0\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mx0\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m/\u001b[0m\u001b[0mdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 9\u001b[0;31m         \u001b[0mdelta\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdx\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     10\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'Root is at: '\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     11\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'f(x) at root is: '\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-19-c66369cbf351>\u001b[0m in \u001b[0;36mdx\u001b[0;34m(f, x)\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mmath\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mdx\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0mabs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mnewtons_method\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-19-c66369cbf351>\u001b[0m in \u001b[0;36mf\u001b[0;34m(x)\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 14\u001b[0;31m     \u001b[0;32mreturn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmath\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0macos\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m**\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m/\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mdf\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: math domain error"
     ]
    }
   ],
   "source": [
    "import math\n",
    "def dx(f, x):\n",
    "    return abs(0-f(x))\n",
    "\n",
    "def newtons_method(f, df, x0, e):\n",
    "    delta = dx(f, x0)\n",
    "    while delta > e:\n",
    "        x0 = x0 - f(x0)/df(x0)\n",
    "        delta = dx(f, x0)\n",
    "    print('Root is at: ', x0)\n",
    "    print('f(x) at root is: ', f(x0))\n",
    "\n",
    "def f(x):\n",
    "    return(math.acos(x**2/2))\n",
    "\n",
    "def df(x):\n",
    "    return(-x/(math.sqrt(1-x**4/4)))\n",
    "\n",
    "if __name__==\"__main__\":\n",
    "    newtons_method(f, df, 1.3, 0.3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.02457703000328076"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "math.acos(1.414**2/2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since this is a function that is not continuous at its root (or only continuous from the left or the right, not both), Newton's method will not work well for approximating it. This is because Newton's method relies on linear approximations of the function to get sequentially better estimates of the function at its real root. However, if the function is mostly undefined, we are unable to sequentially estimate the root as when we get closer to the root, we get an undefined function. Newton's method will only work for points extremely close to the root which defeats the purpose of the approximation."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
